### \_\_init\_\_.py

​	**区别python包和普通文件夹**，就是看文件夹中是否有`__init__.py`文件。在这个文件中可以编写代码，也可以什么都不写，只用它来标注这是一个python包。当一个包，被导入时，这个文件将自动的被执行。如果这里面有内容的话，想要调用这里面的内容，直接用 **包名.内容**即可调用。

​	当其他文件要导入该包中的模块时，需要在`__init__.py`文件中，指定要导出的模块，这样外界才能导入相应的模块，没有指定的模块，外界查看不到。

假设有一个包pack，里面有两个模块，一个test1，一个test2。

在`__init__`文件中，只导入test1，那么外界只能导入test1模块，不能导入test2模块。

```python
# 从当前目录导入模块列表
from . import test1
```

在外部文件中

```python
from pack import test1 # 成功

from pack import test2 # 失败
```





###<sub>--</sub>all<sub>--</sub>

​	在使用 from 模块 import * 时，如果想指定 * 的内容，并不想完全的把这个模块里的所有内容都导入，可以在要导入的模块之前加上 **<sub>--</sub>all<sub>--</sub> = [函数1,  变量2， 函数3...]** 。这样再使用from 模块 import * 导入时，只导入了all里面的内容。



### 导入的模块中有同名的方法

那么后面导入的模块会**覆盖**前面导入的模块中同名的方法。当有同名的方法时，使用`as`关键字为同名的方法起个别名。

在本文件导入模块时，实质上是本文件内有个变量名指向那个模块。比如`import os`，实质在本文件中创建了os这个对象名指向了那个模块。里面的函数或者属性，都是这个对象的函数和属性。





### \_\_name\_\_

使用`__name__`可以保证只在运行时，代码才被执行，被当作模块导入时，主函数不会被执行。

```python
def main():
	pass
	
if __name__ == "__main__":
    main()
```





