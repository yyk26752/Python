### 浅拷贝

使用copy模块下的**copy函数**进行浅拷贝

```python
a = [1, 2]
b = [3, 4]
c = [a, b]
id(a), id(c[0])
# (1583205726088, 1583205726088)

d = c
e = copy.copy(c)

id(c), id(d), id(e)
# (1583205566152, 1583205566152, 1583205683464)

id(c[0]), id(d[0]), id(e[0])
#  (1583205726088, 1583205726088, 1583205726088)

a.append(3)
c, d, e
# ([[1, 2, 3], [3, 4]], [[1, 2, 3], [3, 4]], [[1, 2, 3], [3, 4]])
```

从上述例子中，第4行可以看出c中的元素都是**a，b的引用**。d=c，是d也指向了c这块内存地址。当a发生变化时，c，d都跟着变化。

使用了copy.copy函数时，e和d为不同的内存地址，但是e中的元素还是指向a，b，所以只是外部列表的地址变了。当a发生变化时，e也会变化。**所以浅拷贝只改变了最外层**，内部的引用不会发生变化。

```python
c = (1, 2)
d = copy.copy(c)
id(c), id(d)
# (1583204770312, 1583204770312)
```

从上述可以看出，当浅拷贝的是**不可变数据类型**时，且**元组内的元素也是不可变**的，并不会开辟新的地址（因为不能改变，没有必要开辟新的内存），而是直接指向该对象。

#### 列表的切片

```python
a = [1, 2]
b = [3, 4]
c = [a, b]
d = c[:]

id(c), id(d)
# (1583205723784, 1583205937352)

id(c[0]), id(d[0])
# (1583205700232, 1583205700232)
```

**列表的切片、字典的copy操作都属于浅拷贝**





### 深拷贝

开辟新的空间来存储变量的值，将新变量指向该空间。即两个变量指向的内存地址不同。

copy模块下的**deepcopy**函数

```python
import copy

a = [1, 2]
c = copy.deepcopy(a)
id(a), id(c)
# (1583205940488, 1583205683464) 不同

b = [3, 4]
e = [a, b]
f = copy.deepcopy(e)
id(e), id(f)
# (1583207236808, 1583207236552) 不同

id(e[0]), id([f[0]])
# (1583207272776, 1583207236104) 不同

aa = (1, 2)
bb = copy.deepcopy(aa)
id(aa), id(bb)
# (1583205649608, 1583205649608) 相同
```

从上述例子看出，深拷贝是从里里外外都复制了一份新的。

如果是**不可变类型**，一样不会开辟新的内存。



**上述的不可变类型，比如元组指的是里面的元素也是不可变的，如果里面元素是可变的，见下**

```python
import copy

a = [1, 2]
b = [3, 4]
c = (a, b)

d = copy.copy(c)
e = copy.deepcopy(c)

id(c), id(d), id(e)
# (1583205662088, 1583205662088, 1583205685832)
```

可以看到，**浅拷贝仍然是指向c**，而**深拷贝是开辟了新的内存**，指向了新的地址。





### 总结

从上述可以得出：

- 浅拷贝只拷贝最外层，如果最外层是不可变类型，则copy.copy，是直接引用指向。如果是可变类型，则重新开辟空间。里面的数据仍然是引用指向。
- 深拷贝则是从外层到内层都拷贝，只要遇到有哪里是可变类型，则深拷贝都完全重新复制一份内容。如果从里到外都是不可变，则深拷贝也是引用指向。